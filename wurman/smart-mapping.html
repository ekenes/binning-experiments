<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="initial-scale=1,maximum-scale=1,user-scalable=no"
    />

    <title>
      Binning with aggregate fields | Sample | ArcGIS API for JavaScript 4.24
    </title>

    <script type="module" src="https://js.arcgis.com/calcite-components/1.0.0-beta.97/calcite.esm.js"></script>
    <link rel="stylesheet" type="text/css" href="https://js.arcgis.com/calcite-components/1.0.0-beta.97/calcite.css"/>

    <link
      rel="stylesheet"
      href="https://js.arcgis.com/4.26/esri/themes/light/main.css"
    />


    <style>
      html,
      body,
      #viewDiv {
        padding: 0;
        margin: 0;
        height: 100%;
        width: 100%;
      }
      .description {
        background-color: white;
        padding: 10px;
      }
      .title {
        background-color: inherit;
        text-align: center;
        font-size: 16pt;
        padding: 5px 10px 10px 10px;
        color: #363636
      }

      #infoDiv {
        padding: 10px;
        display: flex;
      }

      #sliders {
        /* flex-direction: column; */
        height: fit-content;
      }

      #smartMappingDiv{
        width: 250px;
      }

      .esri-size-slider .esri-slider .esri-slider__content {
        height: 150px;
      }
      .esri-color-slider .esri-slider .esri-slider__content {
        height: 150px;
      }

      #binLevelSlider{
        height: 50px;
      }

      #gridSizeSlider{
        height: 50px;
      }

      #overlayDiv {
        z-index: 1;
        position: absolute;
        margin: auto auto;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        width: 300px;
        height: 240px;
        padding: 10px;
        background-color: white;
        border: 1px solid grey;
        visibility: hidden;
      }

    </style>

    <script src="https://js.arcgis.com/4.26/"></script>

    <script type="text/javascript">
      require([
        "esri/WebMap",
        "esri/views/MapView",
        "esri/layers/FeatureLayer",
        "esri/layers/support/AggregateField",
        "esri/smartMapping/heuristics/binLevel",
        "esri/smartMapping/heuristics/scaleRange",
        "esri/smartMapping/statistics/summaryStatistics",
        "esri/smartMapping/statistics/spatialStatistics",
        "esri/smartMapping/statistics/histogram",
        "esri/smartMapping/symbology/location",
        "esri/smartMapping/renderers/color",
        "esri/smartMapping/renderers/type",
        "esri/layers/support/LabelClass",
        "esri/widgets/Legend",
        "esri/widgets/Expand",
        "esri/widgets/BasemapGallery",
        "esri/widgets/Home",
        "esri/widgets/smartMapping/SizeSlider",
        "esri/widgets/smartMapping/ColorSlider",
        "esri/widgets/Slider",
        "esri/Color"
      ], function (
        WebMap,
        MapView,
        FeatureLayer,
        AggregateField,
        binLevel,
        scaleRange,
        summaryStatistics,
        spatialStatistics,
        histogram,
        locationSymbology,
        colorRendererCreator,
        typeRendererCreator,
        LabelClass,
        Legend,
        Expand,
        BasemapGallery,
        Home,
        SizeSlider,
        ColorSlider,
        Slider,
        Color
      ) {
        (async () => {

          let portalItemUrl = "";

          function getUrlParams() {
            const queryParams = document.location.search.substr(1);
            let result = {};

            queryParams.split("&").forEach(function(part) {
              var item = part.split("=");
              result[item[0]] = decodeURIComponent(item[1]);
            });

            return result;
          }

          // function to set an id as a url param
          function setUrlParams(id, layerId, portal) {
            window.history.pushState("", "", `${window.location.pathname}?id=${id}&layerId=${layerId}&portal=${portal}`);
          }

          async function createLayer(){

            let layer = null;

            let { id, portal, layerId, url } = getUrlParams();

            if(!url){
              if(!id){
                id = "94b553493bcf432fad439adbde231fbb";
              }

              if(!layerId){
                layerId = 0;
              }

              if(!portal){
                portal = "https://www.arcgis.com/";
              }

              setUrlParams(id, layerId, portal);

              layer = new FeatureLayer({
                portalItem: {
                  id,
                  portal: {
                    url: portal
                  }
                },
                layerId
              });
            } else {
              portal = null;
              id = null;
              layerId = null;

              layer = new FeatureLayer({
                url
              });
            }

            layer.opacity = 1;
            layer.minScale = 0;
            layer.maxScale = 0;

            await layer.load();

            if(layer.geometryType !== "point" && layer.geometryType !== "polygon"){
              alert("Only point or polygon layers are valid.");
              throw new Error("Only point layers are valid.");
            }

            return layer;
          }

          const layer = await createLayer();

          const map = new WebMap({
            basemap: "gray-vector",
            layers: [layer]
          });

          const view = new MapView({
            container: "viewDiv",
            map,
            scale: 144447.638572,
            center: [-90.16232569699594, 29.97990166495397]
          });

          await view.when(async () => {
            await layer.load();
            const title = layer.title + " (Wurman dots)";
            const save = document.getElementById("saveWebMap");
            save.disabled = false;
            save.addEventListener("click", () => {
              // item automatically casts to a PortalItem instance by saveAs
              const item = {
                title
              };

              // Update properties of the WebMap related to the view.
              // This should be called just before saving a webmap.
              map.updateFrom(view).then(() => {
                map
                  .saveAs(item)
                  // Saved successfully
                  .then((item) => {
                    const itemPageUrl = `${item.portal.url}/home/item.html?id=${item.id}`;
                    const link = `<a target="_blank" href="${itemPageUrl}">${title}</a>`;

                    statusMessage(
                      "Save WebMap",
                      `<br> Successfully saved as <i>${link}</i>`
                    );
                  })
                  // Save didn't work correctly
                  .catch((error) => {
                    if (error.name != "identity-manager:user-aborted") {
                      statusMessage("Save WebMap", `<br> Error ${error}`);
                    }
                  });
              });
            });

            const overlay = document.getElementById("overlayDiv");
            const ok = overlay.getElementsByTagName("input")[0];

            function statusMessage(head, info) {
              document.getElementById("head").innerHTML = head;
              document.getElementById("info").innerHTML = info;
              overlay.style.visibility = "visible";
            }

            ok.addEventListener("click", () => {
              overlay.style.visibility = "hidden";
            });
          });

          const { extent } = await layer.queryExtent();
          view.extent = extent.expand(1.5);

          const binLevelSlider = new Slider({
            container: "binLevelSlider",
            values: [1],
            min: 2,
            max: 7,
            steps: 1,
            disabled: true,
            visibleElements: {
              rangeLabels: true
            },
            layout: "horizontal-reversed",
            labelFormatFunction: (value, type) => {
              if(type === "max"){
                return "Smaller bins";
              }
              if(type === "min"){
                return "Larger bins";
              }
              return value;
            }
          });

          const gridSizeSlider = new Slider({
            container: "gridSizeSlider",
            values: [20],
            min: 4,
            max: 40,
            steps: 1,
            disabled: true,
            visibleElements: {
              rangeLabels: true
            }
          });

          async function createBins(params){
            const { view, layer } = params;

            const fixedBinLevel = await binLevel({ view });
            binLevelSlider.disabled = false;
            binLevelSlider.values = [ fixedBinLevel ];

            layer.featureReduction = {
              type: "binning",
              fixedBinLevel
            };
            const { minScale, maxScale } = await scaleRange({ layer, view, forBinning: true });

            const outlineColor = "gray";
            const featureReduction = {
              type: "binning",
              fixedBinLevel,

              fields: [
                new AggregateField({
                  name: "aggregateCount",
                  alias: "Total count",
                  statisticType: "count"
                }),
              ],

              labelsVisible: false,
              popupEnabled: true,
              popupTemplate: {
                title: "Aggregate summary",
                content: [
                  {
                    type: "text",
                    text: "{aggregateCount} points are within this bin."
                  }
                ],
                fieldInfos: [
                  {
                    fieldName: "aggregateCount",
                    label: "Total count",
                    format: {
                      places: 0,
                      digitSeparator: true
                    }
                  }
                ]
              }
            };

            return featureReduction;
          }

          const rendererStopsSelect = document.getElementById("rendererStopsSelect");
          rendererStopsSelect.disabled = true;

          let sizeSlider = null;
          let colorSlider = null;

          let min, max, minBound, maxBound, binSizePixels, isGrid, field, normalizationField;

          function updateSizeSlider(stats) {
            const { min, max, avg, stddev, minBound, maxBound, histogramResult } = stats;

            if(!sizeSlider){
              sizeSlider = new SizeSlider({
                min,
                max,
                stops: [
                  { value: minBound, size: 4 },
                  { value: maxBound, size: 40 }
                ],
                histogramConfig: {
                  bins: histogramResult.bins,
                  average: avg,
                  standardDeviation: stddev,
                  standardDeviationCount: 2
                },
                container: "sizeSlider"
              });

              sizeSlider.on(["segment-drag", "thumb-change", "thumb-drag"], async (event) => {
                const minBound = sizeSlider.stops[0].value;
                const maxBound = sizeSlider.stops[1].value;
                const forBinning = Boolean(layer.featureReduction);
                const gridSize = gridSizeSlider.values[0];

                const renderer = await updateWurmanDotRenderer({
                  min, max, minBound, maxBound, gridSize
                }, {
                  view, layer, field, normalizationField, forBinning
                });

                if(forBinning){
                  const featureReduction = layer.featureReduction.clone();
                  featureReduction.renderer = renderer;
                  layer.featureReduction = featureReduction;
                } else {
                  layer.renderer = renderer;
                }
              });
            } else {
              sizeSlider.set({
                min,
                max,
                stops: [
                  { value: minBound, size: 4 },
                  { value: maxBound, size: 40 }
                ],
                histogramConfig: {
                  bins: histogramResult.bins,
                  average: avg,
                  standardDeviation: stddev,
                  standardDeviationCount: 2
                }
              });
            }
          }

          const colorSliderContainer = document.getElementById("colorSliderContainer");

          function updateColorSlider(vv, stats, histogramResult) {

            if(colorSlider && !vv){
              colorSlider.destroy();
              colorSlider.container = null;
              colorSlider = null;
              return;
            }

            if(!vv || !stats || !histogram){
              return;
            }

            const { min, max, avg, stddev } = stats;
            const theme = colorThemeSelect.value;
            const primaryHandleEnabled = theme === "above-and-below" || theme === "extremes" || theme === "centered-on";
            const handlesSyncedToPrimary = false;
            const syncedSegmentsEnabled = true;
            const visibleElements = {
              interactiveTrack: true
            };

            if(!colorSlider){
              colorSlider = new ColorSlider({
                primaryHandleEnabled,
                handlesSyncedToPrimary,
                syncedSegmentsEnabled,
                visibleElements,
                min,
                max,
                stops: vv.stops,
                histogramConfig: {
                  bins: histogramResult.bins,
                  average: avg,
                  standardDeviation: stddev,
                  standardDeviationCount: 2
                },
                container: document.createElement("div")
              });

              colorSliderContainer.appendChild(colorSlider.container);

              colorSlider.on(["segment-drag", "thumb-change", "thumb-drag"], async (event) => {
                const forBinning = Boolean(layer.featureReduction);
                const renderer = forBinning ? layer.featureReduction?.renderer.clone() : layer.renderer.clone();

                const colorVariable = getColorVariable(renderer);

                if(colorVariable){
                  colorVariable.stops = colorSlider.stops;
                  renderer.visualVariables = [ colorVariable ];
                }

                if(forBinning){
                  const featureReduction = layer.featureReduction.clone();
                  featureReduction.renderer = renderer;
                  layer.featureReduction = featureReduction;
                } else {
                  layer.renderer = renderer;
                }
              });
            } else {
              colorSlider.set({
                primaryHandleEnabled,
                min,
                max,
                stops: vv.stops,
                histogramConfig: {
                  bins: histogramResult.bins,
                  average: avg,
                  standardDeviation: stddev,
                  standardDeviationCount: 2
                }
              });
            }
          }

          function getColorVariable(renderer){
            if(renderer.visualVariables && renderer.visualVariables.length){
              const colorVariable = renderer.visualVariables.filter(vv => vv.type === "color")[0];
              return colorVariable;
            }
            return null;
          }

          async function getBinSizePixels(params){
            const { layer, view, forBinning } = params;
            const layerView = await view.whenLayerView(layer);

            if(forBinning){
              const binGraphicsResponse = await layerView.queryAggregates();
              const binGraphics = binGraphicsResponse.features;

              if(binGraphics.length === 0){
                return 1;
              }

              const sampleBin = binGraphics[Math.floor(binGraphics.length * 0.5)]?.geometry;

              const sampleBinWidth = sampleBin.extent.width;
              const sampleBinHeight = sampleBin.extent.height;

              const binSize = sampleBinWidth < sampleBinHeight ? sampleBinWidth : sampleBinHeight;
              const binSizePixels = binSize / view.resolution;

              return {
                binSizePixels,
                isGrid: true
              };
            } else {
              const layerGraphicsResponse = await layerView.queryFeatures();
              const binGraphics = layerGraphicsResponse.features;

              if(binGraphics.length === 0){
                return 1;
              }

              const { minSize, maxSize, avgSize } = await spatialStatistics({
                features: binGraphics,
                geometryType: "polygon"
              });

              const threshold = 0.1;
              const isGrid = !(minSize < avgSize * (1 - threshold) || maxSize > avgSize * (1 + threshold));
              const binSize = isGrid ? avgSize * (1-threshold) : (2 * minSize);
              const binSizePixels = binSize / view.resolution;

              return {
                binSizePixels,
                isGrid
              };
            }
          }

          function getPrimitiveOverrides(rendererParams, stats){
            const { view, field, normalizationField, colorField, uniqueValueInfos, gridSize } = rendererParams;
            const { minBound, maxBound, binSizePixels, isGrid } = stats;

            let value;
            let fields;
            if(!field){
              value = 0;
            } else {
              value = `$feature.${field}`;
              fields = `
                $feature.${field};
              `;
            }

            if(normalizationField){
              value = `$feature.${field} / $feature.${normalizationField}`;
              fields = `
                $feature.${field};
                $feature.${normalizationField};
              `;
            }

            const outerRingExpressionInfo = {
              type: "CIMExpressionInfo",
              title: "Size in pixels of outer ring at maxScale",
              expression: isGrid ? `
                var binWidthPixels = ${binSizePixels};
                return (binWidthPixels * (${view.scale} / $view.scale)) * 0.75;
              ` : `${gridSize} * 0.75`,
              returnType: "Default"
            };

            let primitiveOverrides = [
              {
                type: "CIMPrimitiveOverride",
                primitiveName: "outerRing",
                propertyName: "Size",
                valueExpressionInfo: outerRingExpressionInfo
              },
              {
                type: "CIMPrimitiveOverride",
                primitiveName: "innerDot",
                propertyName: "Size",
                valueExpressionInfo: {
                  type: "CIMExpressionInfo",
                  title: "Size in pixels of inner ring at maxScale",
                  // outerSize is the pixel size at the largest scale
                  // The innerSize is determined by multiplying
                  // the outerSize by the forest ratio
                  expression: isGrid ? `
                    ${fields}
                    var value = ${value};

                    var binWidthPixels = ${binSizePixels};
                    var minBound = ${minBound};
                    var maxBound = ${maxBound};
                    var ratio = ( value - minBound) / (maxBound - minBound);

                    var innerRatio = Constrain(ratio, 0, 1);
                    var outerSize = binWidthPixels * (${view.scale} / $view.scale);
                    // 0 is what the minSize could be if provided in UI
                    var innerSize = (outerSize * innerRatio) + 0;
                    // pixel to point conversion
                    return innerSize * 0.75;
                  ` : `
                    ${fields}
                    var value = ${value};

                    var binWidthPixels = ${binSizePixels};
                    var minBound = ${minBound};
                    var maxBound = ${maxBound};
                    var ratio = ( value - minBound) / (maxBound - minBound);

                    var innerRatio = Constrain(ratio, 0, 1);
                    var outerSize = ${gridSize} * 0.75;
                    // 0 is what the minSize could be if provided in UI
                    var innerSize = (outerSize * innerRatio) + 0;
                    // pixel to point conversion
                    return innerSize * 0.75;
                  `,
                  returnType: "Default"
                }
              }
            ];

            if(colorField && uniqueValueInfos){

              let uniqueValuesWithColors = {};

              for (let i in uniqueValueInfos){
                const info = uniqueValueInfos[i];
                uniqueValuesWithColors[info.value] = info.symbol.color.toJSON();
              }

              const colorOverrideExpression = `
                $feature.${colorField};
                var value = $feature.${colorField};

                var uniqueValueInfos = ${JSON.stringify(uniqueValuesWithColors)};

                if(HasValue(uniqueValueInfos, value)){
                  return uniqueValueInfos[value];
                }
                return [128,128,128,255];
              `;

              const innerDotColorOverride = {
                type: "CIMPrimitiveOverride",
                primitiveName: "innerDotFill",
                propertyName: "Color",
                valueExpressionInfo: {
                  type: "CIMExpressionInfo",
                  title: "unique value color",
                  expression: colorOverrideExpression,
                  returnType: "Default"
                }
              };

              const outerDotColorOverride = {
                type: "CIMPrimitiveOverride",
                primitiveName: "outerRingFill",
                propertyName: "Color",
                valueExpressionInfo: {
                  type: "CIMExpressionInfo",
                  title: "unique value color",
                  expression: colorOverrideExpression,
                  returnType: "Default"
                }
              };

              primitiveOverrides.push(innerDotColorOverride);

              if(colorRingCheckbox.checked){
                primitiveOverrides.push(outerDotColorOverride);
              }
            }

            if(!isGrid){
              const stepXOverride = {
                type: "CIMPrimitiveOverride",
                primitiveName: "stepXY",
                propertyName: "stepX",
                valueExpressionInfo: outerRingExpressionInfo
              };

              const stepYOverride = {
                type: "CIMPrimitiveOverride",
                primitiveName: "stepXY",
                propertyName: "stepY",
                valueExpressionInfo: outerRingExpressionInfo
              };

              primitiveOverrides = [...primitiveOverrides, stepXOverride, stepYOverride];
            }

            return primitiveOverrides;
          }

          async function createWurmanDotRenderer(params){
            const { layer, view, field, normalizationField, gridSize, forBinning } = params;

            const statParams = {
              layer,
              view,
              field,
              normalizationField,
              normalizationType: normalizationField ? "field" : null,
              forBinning
            };

            const stats = await summaryStatistics(statParams);
            const histogramResult = await histogram({
              ...statParams,
              numBins: 60
            });

            min = 0;
            max = stats.max;
            const mean = stats.avg;
            const stddevHalf = stats.avg + (0.5 * stats.stddev);
            const stddev1 = stats.avg + stats.stddev;
            const stddev2 = stats.avg + (2 * stats.stddev);

            const maxBoundDictionary = {
              "mean": mean,
              "0.5-std-dev": stddevHalf,
              "1-std-dev": stddev1,
              "2-std-dev": stddev2,
              "max": max
            };

            maxBound = maxBoundDictionary[rendererStopsSelect.value];
            minBound = min;

            const { primaryScheme } = await locationSymbology.getSchemes({
              basemap: view.map.basemap,
              geometryType: layer.geometryType
            });

            const fillColor = primaryScheme.color;
            const ringColor = primaryScheme.color.clone();
            ringColor.a = 0.4;

            const getBinSizePixelsResult = await getBinSizePixels({ view, layer, forBinning });
            binSizePixels = getBinSizePixelsResult.binSizePixels;
            isGrid = getBinSizePixelsResult.isGrid;

            let isUniqueValueColor = false;
            let uniqueValueInfos, colorVariable, visualVariables, colorStats, colorHistogramResult;

            if(colorFieldSelect.value) {

              isUniqueValueColor = forBinning ? featureReduction.fields.some(field => {
                return field.onStatisticField === colorFieldSelect.value &&
                  field.statisticType === "mode";
              }) : layer.fields.some(field => {
                return field.name === colorFieldSelect.value &&
                  field.type === "string";
              });

              colorNormalizationFieldSelect.disabled = isUniqueValueColor;
              colorThemeSelect.disabled = isUniqueValueColor;

              if(!isUniqueValueColor){
                const { visualVariable, statistics } = await colorRendererCreator.createVisualVariable({
                  layer,
                  view,
                  field: getColorAggregateFieldName(isUniqueValueColor && forBinning),
                  normalizationField: colorNormalizationFieldSelect.value,
                  normalizationType: colorNormalizationFieldSelect.value ? "field" : null,
                  theme: colorThemeSelect.value,
                  forBinning
                });

                colorVariable = visualVariable;
                colorStats = statistics;
                visualVariables = [ colorVariable ];

                colorHistogramResult = await histogram({
                  layer,
                  view,
                  field: getColorAggregateFieldName(isUniqueValueColor && forBinning),
                  normalizationField: colorNormalizationFieldSelect.value,
                  normalizationType: colorNormalizationFieldSelect.value ? "field" : null,
                  forBinning,
                  numBins: 60
                });

              } else {

                const uniqueValueRendererResponse = await typeRendererCreator.createRenderer({
                  layer,
                  view,
                  field: getColorAggregateFieldName(false),
                  numTypes: 10,
                  sortBy: "count",
                  defaultSymbolEnabled: true,
                  forBinning
                });

                uniqueValueInfos = uniqueValueRendererResponse.renderer.uniqueValueInfos;
              }
            }
            updateColorSlider(colorVariable, colorStats, colorHistogramResult);

            const primitiveOverrides = getPrimitiveOverrides({
              view, field, normalizationField,
              colorField: getColorAggregateFieldName(isUniqueValueColor && forBinning), uniqueValueInfos,
              gridSize: gridSize || 20
            }, {
              minBound, maxBound, binSizePixels, isGrid
            });

            const markerPlacement = isGrid ? null : {
              primitiveName: "stepXY",
              type: "CIMMarkerPlacementInsidePolygon",
              gridType: "Fixed",
              randomness: 100,
              seed: 13,
              // stepX: 32,  prim override driven
              // stepY: 32,
              clipping: "DoNotClip"
            };

            gridSizeSlider.disabled = isGrid;

            const renderer = {
              type: "simple",
              visualVariables,
              symbol: {
                type: "cim",
                data: {
                  type: "CIMSymbolReference",
                  symbol: {
                    type: "CIMPointSymbol",
                    symbolLayers: [
                      {
                        type: "CIMVectorMarker",
                        enable: true,
                        anchorPoint: { x: 0, y: 0 },
                        anchorPointUnits: "Relative",
                        primitiveName: "innerDot",
                        frame: { xmin: 0.0, ymin: 0.0, xmax: 17.0, ymax: 17.0 },
                        markerGraphics: [
                          {
                            type: "CIMMarkerGraphic",
                            geometry: {
                              rings: [
                                [
                                  [8.5, 0.2],
                                  [7.06, 0.33],
                                  [5.66, 0.7],
                                  [4.35, 1.31],
                                  [3.16, 2.14],
                                  [2.14, 3.16],
                                  [1.31, 4.35],
                                  [0.7, 5.66],
                                  [0.33, 7.06],
                                  [0.2, 8.5],
                                  [0.33, 9.94],
                                  [0.7, 11.34],
                                  [1.31, 12.65],
                                  [2.14, 13.84],
                                  [3.16, 14.86],
                                  [4.35, 15.69],
                                  [5.66, 16.3],
                                  [7.06, 16.67],
                                  [8.5, 16.8],
                                  [9.94, 16.67],
                                  [11.34, 16.3],
                                  [12.65, 15.69],
                                  [13.84, 14.86],
                                  [14.86, 13.84],
                                  [15.69, 12.65],
                                  [16.3, 11.34],
                                  [16.67, 9.94],
                                  [16.8, 8.5],
                                  [16.67, 7.06],
                                  [16.3, 5.66],
                                  [15.69, 4.35],
                                  [14.86, 3.16],
                                  [13.84, 2.14],
                                  [12.65, 1.31],
                                  [11.34, 0.7],
                                  [9.94, 0.33],
                                  [8.5, 0.2]
                                ]
                              ]
                            },
                            symbol: {
                              type: "CIMPolygonSymbol",
                              symbolLayers: [
                                {
                                  type: "CIMSolidFill",
                                  enable: true,
                                  color: fillColor.toJSON(),
                                  primitiveName: "innerDotFill"
                                }
                              ]
                            }
                          }
                        ],
                        scaleSymbolsProportionally: true,
                        respectFrame: true,
                        markerPlacement
                      },
                      {
                        type: "CIMVectorMarker",
                        enable: true,
                        colorLocked: !colorRingCheckbox.checked,
                        anchorPoint: { x: 0, y: 0 },
                        anchorPointUnits: "Relative",
                        primitiveName: "outerRing",
                        frame: { xmin: 0.0, ymin: 0.0, xmax: 17.0, ymax: 17.0 },
                        markerGraphics: [
                          {
                            type: "CIMMarkerGraphic",
                            geometry: {
                              rings: [
                                [
                                  [8.5, 0.2],
                                  [7.06, 0.33],
                                  [5.66, 0.7],
                                  [4.35, 1.31],
                                  [3.16, 2.14],
                                  [2.14, 3.16],
                                  [1.31, 4.35],
                                  [0.7, 5.66],
                                  [0.33, 7.06],
                                  [0.2, 8.5],
                                  [0.33, 9.94],
                                  [0.7, 11.34],
                                  [1.31, 12.65],
                                  [2.14, 13.84],
                                  [3.16, 14.86],
                                  [4.35, 15.69],
                                  [5.66, 16.3],
                                  [7.06, 16.67],
                                  [8.5, 16.8],
                                  [9.94, 16.67],
                                  [11.34, 16.3],
                                  [12.65, 15.69],
                                  [13.84, 14.86],
                                  [14.86, 13.84],
                                  [15.69, 12.65],
                                  [16.3, 11.34],
                                  [16.67, 9.94],
                                  [16.8, 8.5],
                                  [16.67, 7.06],
                                  [16.3, 5.66],
                                  [15.69, 4.35],
                                  [14.86, 3.16],
                                  [13.84, 2.14],
                                  [12.65, 1.31],
                                  [11.34, 0.7],
                                  [9.94, 0.33],
                                  [8.5, 0.2]
                                ]
                              ]
                            },
                            symbol: {
                              type: "CIMPolygonSymbol",
                              symbolLayers: [
                                {
                                  type: "CIMSolidFill",
                                  enable: showRingCheckbox.checked,
                                  color: ringColor.toJSON(),
                                  primitiveName: "outerRingFill",
                                  effects: [{
                                    type: "CIMGeometricEffectDonut",
                                    width: 0.75
                                  }]
                                }
                              ]
                            }
                          }
                        ],
                        scaleSymbolsProportionally: false,
                        respectFrame: true,
                        markerPlacement
                      }
                    ]
                  },
                  primitiveOverrides
                }
              }
            };

            updateSizeSlider({
              avg: stats.avg,
              stddev: stats.stddev,
              min,
              max,
              minBound,
              maxBound,
              histogramResult
            });

            return renderer;
          }

          async function updateWurmanDotRenderer(updatedValues, rendererParams){
            const { min, max, minBound, maxBound, gridSize  } = updatedValues;
            const { view, layer, field, normalizationField, forBinning }  = rendererParams;
            const renderer = forBinning ? layer.featureReduction?.renderer.clone() : layer.renderer.clone();

            const { binSizePixels, isGrid } = await getBinSizePixels({ view, layer, forBinning });

            const primitiveOverrides = getPrimitiveOverrides({
              view, field, normalizationField, gridSize
            }, {
              minBound, maxBound, binSizePixels, isGrid
            });

            const data = renderer.symbol.data;

            const colorOverrides = data.primitiveOverrides.filter(
              override => override.propertyName === "Color"
            );

            data.primitiveOverrides = colorOverrides.concat(primitiveOverrides);

            return renderer;
          }

          view.ui.add(
            new Home({
              view: view
            }),
            "top-left"
          );

          view.ui.add("infoDiv", "top-right");

          createLegend("crashes-wurman-total");

          view.ui.add(new Expand({
            view,
            expanded: false,
            content: new BasemapGallery({ view }),
            group: "top-left"
          }), "top-left");

          function createLegend (fileName){
            // Add custom legend as an image to an Expand instance

            const descriptionContainer = document.createElement("div");
            descriptionContainer.classList.add("description");

            const descriptionTitle = document.createElement("div");
            descriptionTitle.innerHTML = `<h3>${layer.title}</h3>`;
            descriptionTitle.classList.add("esri-widget");
            // descriptionTitle.classList.add("title");
            descriptionContainer.appendChild(descriptionTitle);

            const image = document.createElement("img");
            image.src = `./assets/${fileName}.png`;
            descriptionContainer.appendChild(image);

            view.ui.add(
              new Expand({
                view: view,
                content: descriptionContainer,
                expandIconClass: "esri-icon-legend",
                group: "top-left"
              }),
              "top-left"
            );

            // Adjusts the size of the legend image
            // based on the size of the view
            view.when()
              .then(adjustLegendByViewSize);

            view.watch("widthBreakpoint", adjustLegendByViewSize);

            function adjustLegendByViewSize() {
              if (view.widthBreakpoint === "xsmall") {
                image.style.width = "100%";
              } else {
                image.style.width = null;
              }
            }
          }

          const fieldSelect = document.getElementById("fieldSelect");
          fieldSelect.disabled = false;
          const normalizationFieldSelect = document.getElementById("normalizationFieldSelect");
          normalizationFieldSelect.disabled = true;
          const colorFieldSelect = document.getElementById("colorFieldSelect");
          colorFieldSelect.disabled = true;
          const colorNormalizationFieldSelect = document.getElementById("colorNormalizationFieldSelect");
          const colorThemeSelect = document.getElementById("colorThemeSelect");
          const statisticTypeSelect = document.getElementById("statisticTypeSelect");
          statisticTypeSelect.disabled = true;
          const colorRingCheckbox = document.getElementById("color-ring");
          const showRingCheckbox = document.getElementById("show-ring");

          await layer.load();
          const forBinning = layer.geometryType === "point";

          const numberFields = await getNumberFields(layer);
          const stringFields = await getStringFields(layer);
          createFieldSelect(fieldSelect, numberFields);
          createColorFieldSelect(colorFieldSelect, stringFields, forBinning);

          if(!forBinning){
            createFieldSelect(normalizationFieldSelect, numberFields);
            createFieldSelect(colorFieldSelect, numberFields);
            createFieldSelect(colorNormalizationFieldSelect, numberFields);
          }

          async function createFeatureReduction () {
            const featureReduction = await createBins({ layer, view });
            layer.featureReduction = featureReduction;
          }

          const createRendererBtn = document.getElementById("createRendererBtn");
          createRendererBtn.addEventListener("click", createRenderer);

          async function createRenderer () {

            const forBinning = layer?.geometryType === "point";
            if(forBinning && layer?.featureReduction?.type !== "binning"){
              await createFeatureReduction();
            }

            fieldSelect.disabled = false;
            normalizationFieldSelect.disabled = false;
            colorFieldSelect.disabled = false;
            statisticTypeSelect.disabled = false;
            rendererStopsSelect.disabled = false;

            field = forBinning ? getAggregateFieldName() : fieldSelect.value;
            normalizationField = normalizationFieldSelect.value;
            // const gridSize = gridSizeSlider.values[0];

            const renderer = await createWurmanDotRenderer({
              layer,
              view,
              field,
              normalizationField,
              forBinning,
              // gridSize
            });

            if(forBinning){
              const featureReduction = layer.featureReduction.clone();
              featureReduction.renderer = renderer;
              layer.featureReduction = featureReduction;
            } else {
              layer.renderer = renderer;
            }
          }

          function getAggregateFieldName(){
            const stat = statisticTypeSelect.value;
            const fieldName = fieldSelect.value;
            if(fieldName === "aggregateCount"){
              return fieldName;
            }
            return `${fieldName}_${stat}`;
          }

          function getColorAggregateFieldName(isType){
            const fieldName = colorFieldSelect.value;
            if(fieldName === "aggregateCount"){
              return fieldName;
            }
            return isType ? `${fieldName}_mode` : fieldName;
          }

          async function selectFieldHandler (event) {
            const forBinning = layer.geometryType === "point";
            const fieldName = fieldSelect.value;

            if(forBinning && fieldName !== "aggregateCount"){
              statisticTypeSelect.disabled = fieldName === "aggregateCount";
              const stat = statisticTypeSelect.value;
              const aggregateField = createAggregateField(fieldName, stat);
              updateFeatureReductionFields(layer, aggregateField);
              updateAggregateFieldSelect(normalizationFieldSelect, aggregateField);
              updateAggregateFieldSelect(colorFieldSelect, aggregateField);
              updateAggregateFieldSelect(colorNormalizationFieldSelect, aggregateField);
            }

            await createRenderer();
          }

          fieldSelect.addEventListener("change", selectFieldHandler);
          statisticTypeSelect.addEventListener("change", selectFieldHandler);
          normalizationFieldSelect.addEventListener("change", createRenderer);
          colorNormalizationFieldSelect.addEventListener("change", createRenderer);
          rendererStopsSelect.addEventListener("change", createRenderer);

          colorRingCheckbox.addEventListener("change", createRenderer);
          showRingCheckbox.addEventListener("change", createRenderer);

          colorFieldSelect.addEventListener("change", async (event) => {
            const fieldName = colorFieldSelect.value;

            const selectedIndex = colorFieldSelect.selectedIndex;
            const optionText = colorFieldSelect.options[selectedIndex].innerText;
            const modeOptionSelected = optionText.indexOf("Predominant value - ") > -1;

            if(fieldName !== "aggregateCount" && modeOptionSelected){
              const aggregateField = createAggregateField(fieldName, "mode");
              updateFeatureReductionFields(layer, aggregateField);
            }

            // colorRingCheckbox.disabled = !modeOptionSelected;
            colorNormalizationFieldSelect.disabled = !fieldName;
            colorThemeSelect.disabled = !fieldName;

            await createRenderer();
          });
          colorThemeSelect.addEventListener("change", createRenderer);

          binLevelSlider.watch("values", ([value]) => {
            if(layer.featureReduction){
              layer.featureReduction.fixedBinLevel = value;
              createRenderer();
            }
          });

          gridSizeSlider.watch("values", async ([value]) => {
            const minBound = sizeSlider.stops[0].value;
            const maxBound = sizeSlider.stops[1].value;
            const forBinning = Boolean(layer.featureReduction);
            const gridSize = value;

            const renderer = await updateWurmanDotRenderer({
              min, max, minBound, maxBound, gridSize
            }, {
              view, layer, field, normalizationField, forBinning
            });

            layer.renderer = renderer;
          });

          async function getNumberFields(layer) {
            await layer.load();

            const validTypes = [ "small-integer", "integer", "single", "double", "long", "number" ];

            return layer.fields
              .filter( field => validTypes.indexOf(field.type) > -1 );
          }

          async function getStringFields(layer) {
            await layer.load();

            const validTypes = [ "string" ];

            return layer.fields
              .filter( field => validTypes.indexOf(field.type) > -1 );
          }

          function createAggregateCountOption(){
            const option = document.createElement("option");
            option.value = "aggregateCount";
            option.label = "Total Count";
            option.selected = true;
            return option;
          }

          function createFieldSelect(select, fields){

            fields.forEach((field, i) => {
              const option = document.createElement("option");
              option.value = field.name;
              option.label = `${field.type} - ${field.alias}`;
              option.text = `${field.type} - ${field.alias}`;

              select.appendChild(option);
            });

            return select;
          }

          function createColorFieldSelect(select, fields, forBinning){

            fields.forEach((field, i) => {
              const option = document.createElement("option");
              option.value = field.name;
              option.label = forBinning ? `Predominant value - ${field.alias}` : field.alias;
              option.text = forBinning ? `Predominant value - ${field.alias}` : field.alias;

              select.appendChild(option);
            });

            return select;
          }

          function createAggregateField(fieldName, stat){
            const aggregateField = new AggregateField({
              name: `${fieldName}_${stat}`,
              alias: `${fieldName} (${stat})`,
              onStatisticField: fieldName,
              statisticType: stat
            });

            return aggregateField;
          }

          function updateFeatureReductionFields(layer, aggregateField){
            const featureReduction = layer.featureReduction.clone();
            if(
              featureReduction.fields.some((field) => field.name === aggregateField.name)
            ){
              return;
            }
            featureReduction.fields.push(aggregateField);
            layer.featureReduction = featureReduction;
            return featureReduction;
          }

          function updateAggregateFieldSelect (select, aggregateField){

            for(let i = 0; i < select.length; i++){
              if(select.options[i].value === aggregateField.name){
                return;
              }
            }

            const option = document.createElement("option");
            option.value = aggregateField.name;
            option.label = aggregateField.alias;
            option.text = aggregateField.alias;
            select.appendChild(option);
          }

        })();
      });
    </script>
  </head>
  <body>
    <div id="viewDiv"></div>
    <div id="infoDiv" class="esri-widget">
      <div id="smartMappingDiv" class="esri-widget">
        <button id="createRendererBtn" class="esri-button">Create Wurman dots</button>

        <!-- Bin size -->
        <div id="binLevelSlider"></div>

        <!-- Bin size -->
        Grid resolution
        <div id="gridSizeSlider"></div>

        Size Field
        <div id="fieldSelectContainer">
          <select id="fieldSelect" class="esri-select">
            <option value="aggregateCount" selected>Total Count</option>
          </select>
        </div>

        Statistic type
        <select id="statisticTypeSelect" class="esri-select" disabled>
          <option value="sum" selected>sum</option>
          <option value="avg">avg</option>
          <option value="min">min</option>
          <option value="max">max</option>
        </select>

        Outer ring value
        <select id="rendererStopsSelect" class="esri-select">
          <option value="mean">mean</option>
          <option value="0.5-std-dev">1/2 std dev</option>
          <option value="1-std-dev">1 std dev</option>
          <option value="2-std-dev" selected>2 std dev</option>
          <option value="max">max</option>
        </select>

        Size Normalization Field
        <div id="normalizationFieldSelectContainer">
          <select id="normalizationFieldSelect" class="esri-select">
            <option value="" selected></option>
            <option value="aggregateCount" >Total Count</option>
          </select>
        </div>

        Color field
        <div id="colorFieldSelectContainer">
          <select id="colorFieldSelect" class="esri-select">
            <option value="" selected></option>
            <option value="aggregateCount">Total Count</option>
          </select>
        </div>

        Color Normalization Field
        <div id="colorNormalizationFieldSelectContainer">
          <select id="colorNormalizationFieldSelect" class="esri-select" disabled>
            <option value="" selected></option>
            <option value="aggregateCount" >Total Count</option>
          </select>
        </div>

        Color Theme
        <div id="colorThemeSelectContainer">
          <select id="colorThemeSelect" class="esri-select" disabled>
            <option value="high-to-low" selected>High to low</option>
            <option value="above-and-below">Above and below</option>
            <option value="above">Above</option>
            <option value="below">Below</option>
            <option value="centered-on">Centered on</option>
            <option value="extremes">Extremes</option>
          </select>
        </div>

        <div>
          <input type="checkbox" id="color-ring" checked> Apply color to ring?
        </div>
        <div>
          <input type="checkbox" id="show-ring" checked> Show outer ring
        </div>

        <input
          id="saveWebMap"
          type="button"
          value="Save"
          disabled
          class="esri-button"
        />

      </div>

      <div id="sliders">

        <div id="sizeSliderContainer">
          <div id="sizeSlider"></div>
        </div>

        <div id="colorSliderContainer">
        </div>

      </div>
      <div id="legendDiv"></div>
    </div>
    <div id="overlayDiv" class="esri-widget">
      <h4 class="esri-heading" id="head"></h4>
      <label id="info"></label>
      <input type="button" value="OK" class="esri-button" />
    </div>
  </body>
</html>